N 계층 아키텍처 / MVC 패턴 (Model - Views - Controller 구조)

뷰 = 유저가 보는 화면 HTML 형식 = handlebars로 작성합니다.

컨트롤러는 따로 컨트롤러를 두지는 않고 app.js 안에 라우터 함수들로 분리합니다.

서비스 같은 경우는 post-service.js로 만들고

DB는 몽고DB를 사용합니다.

1. 먼저 npm init을 통해 Node js 프로젝트를 초기화합니다. => package.json 파일 생성
여기서 나오는 Script는 
"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"}

테스트가 없다는 에러를 내면서 종료합니다.

2. express 패키지를 설치합니다. 버전은 맞춰야 에러가 최소한으로 나기 때문에
express@4.17.3 버전 mongodb는 4.13.0 버전입니다.

익스프레스 : 마이크로 프레임워크 / 최소 기능을 가지면서 필요한 기능을 플러그인으로 확장하는 프레임워크를 의미

3계층 구조 설명
컨트롤러 계층 : 뷰에서 넘어온 요청을 받아서 권한을 체크, 유효성을 검증 한 후 서비스 계층으로 넘김
서비스 계층 : 비즈니스 로직을 처리 각각 다른 컨트롤러에서 서비스를 재사용 가능

익스프레스의 역할
라우터 => 컨트롤러 역할 
서비스 계층 => 클래스 또는 함수를 작성 
몽고 DB => 데이터 액세스 계층 역할

1. 뷰 역할을 하는 웹페이지에서 익스프레스로 요청을 보냅니다.
2. 받은 요청에 대한 인증, 유효성 검증 등을 하고 문제가 없다면 비즈니스 로직을 처리하는 서비스 계층에 있는 함수를 호출합니다.
3. 서비스에서는 컨트롤러에서 받은 데이터로 비즈니스 로직을 처리하거나 데이터 액세스로 넘기는 모델 객체를 생성합니다.
4. 데이터 액세스에서는 서비스 계층에서 받은 데이터를 생성/수정/삭제/조회 등을 수행합니다.
5. 그리고 나서 데이터 처리 결과를 다시 서비스로 넘깁니다.
6. 서비스는 받은 데이터 결과를 컨트롤러로 넘깁니다.
7. 컨트롤러에서는 서비스에 받은 데이터와 실행 결과에 대한 코드 등의 데이터를 웹페이지에 응답으로 보냅니다. 
뷰에서는 웹페이지에서 받은 응답에 있는 값을 확인하고 웹 페이지를 갱신합니다.


웹페이지를 보여주기 위해 템플릿 엔진이 필요합니다. 

템플릿 엔진 : 퍼그, EJS, 머시태시 등

퍼그 : HTML이 아닌 다른 포맷으로 웹페이지를 작성해야 하므로 제외
EJS : 표현식이 지저분함
머스태시 : 다양한 언어에서 사용되는 템플릿 엔진과 유사 / 핸들바에 비해 기능이 적다.
핸들바 : 머스태시와 호환되면서 추가 기능을 제공하므로 핸들바로 사용한다.
=> express-handlebars@6.0.3 

<app.js>
1. 익스프레스에서 사용할 템플릿 엔진을 등록하는 코드 "handlebars"는 파일의 확장자로 사용할 이름 "hbs" 등의 다른 이름으로도 변경은 가능하다.
2. 웹 페이지에서 사용할 템플릿 엔진도 설정한다. 이름은 "handlebars" 만약 1.에서 이름이 hbs라면 2도 hbs로 진행해야한다. 
3. 뷰로 사용할 파일들의 디렉터리를 설정하는 코드 기본적으로 views로 되었긴하지만 node를 실행하는 디렉터리의 상대 경로로 지정되기 때문에 
   __dirname을 활용하여 절대 경로로 지정한다.
4. /같은 경우는 라우팅하는 패스입니다. localhost:3000/으로 접근할 때 콜백 함수를 실행합니다. home은 템플릿 파일의 이름입니다. views가 기본 경로이고
   handlebars가 확장자 임으로 views/home.handlebars 파일에 데이터를 랜더링합니다. 렌더링 시에 title과 message 값이 객체로 들어가게됩니다.

<layouts>
1. body를 중괄호 3개로 감싸는 이유
handlebars.engine에 layoutsDir 항목을 추가하면 기본 레이아웃 디렉터리를 변경할 수 있습니다.
app.engine("handlebars", handlebars.engine({ layoutsDir: "views"}))
혹은 기본 레이아웃을 사용하고 싶지 않으면 라우터의 결과 객체에 layout: false를 추가하면 됩니다.


구조(backend)
글쓰기 -> 리스트 -> 상세페이지 -> 글 수정, 삭제 -> 댓글 추가 -> 댓글 삭제 순서
DB : 몽고디비
모든 API = async await 구문을 사용해 구현

`` (백틱)은 템플릿 리터럴(template literals)을 나타내는 것입니다. 
ES6(ECMAScript 2015)에서 도입된 문법 중 하나로, 문자열을 간단하게 표현하고 문자열 중간에 변수나 표현식을 삽입할 수 있게 해줍니다.


app.get("/", async (req, res) => {
  const page = parseInt(req.query.page) || 1; // 현재 페이지 데이터 
  const search = req.query.search || ""; // 검색어 데이터
  try {
    //2. postService.list에서 글 목록과 페이지네이터를 가져옴
    const [posts, paginator] = await postService.list(collection, page, search);
    //3. 리스트 페이지 렌더링 
    res.render("home", { title: "테스트 게시판", search, paginator, posts});
  } catch (error) {
    console.error(error);
    res.render("home", { title: "테스트 게시판"});
    // 4. 에러가 나는 경우는 빈 값으로 테더링
  }
});
1. get으로 API를 호출해 URL 뒤에 변수를 추가하는 경우 req.query 객체로 변수의 값을 받아 올 수 있습니다. 리스트 페이지이므로 현재 데이터와 검색어 데이터를 req.query의 page, search로 각각 가지고 있습니다. ||는 이전 값이 빈 값이거나 null인 경우 || 뒤의 값을 기본값으로 설정하는 데 사용합니다. 예를 들어 page 변수에 값이 없다면 1을 기본값으로 사용합니다.

2. 리스트의 데이터를 가져오는 구체적인 로직은 모두 postSercie에 있습니다. 이 부분은 psotService에 list() 함수를 추가하면서 알아보겠습니다. 반환값을 받는 부분이 배열처럼 되는데,
반환값이 배열인 경우 배열의 인덱스에 변수를 매핑해서 받을 수 있습니다. 예를 들어 다음과 같은 코드가 있다고 하겠습니다.
const [name, age] = ["승규", 30];
이 경우 각각 name에는 "승규" 문자열이, age에는 30이라는 숫자가 들어가게 됩니다.

3. 리스트 페이지를 렌더링하는 코드입니다. search, paginator, posts를 할당하는 부분이 title과 약간 다르게 보일 수 있습니다. 객체에 값을 할당할 때 값으로 사용하는 변수명과 키의 이름이 같다면 변수만 바로 넣어도 됩니다. 즉 { search: search, paginator: paginator, posts: posts }는 {search, paginator, posts}와 같습니다.

4. 리스트를 불러오는 도중 에러가 나는 경우 빈 값으로 렌더링합니다. 여기서 에러를 잡아주지 않으면 웹페이지에 에러 코드가 나오므로 예외 처리르 하는 것이 좋습니다. 지면 관계상 거의 대부분 예외 처리를 하지 않습니다만, 실무에서는 예외 처리를 꼼꼼하게 하는 것이 기본입니다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
findOneAndUpdate() 함수 정의는 db.collection.findOneAndUpdate(filter, update, options)입니다. filter는 원하는 데이터를 가져오고, update는 필터를 사용해 찾은 도큐먼트에 갱신할 데이터에
대한 내용을 넣습니다. options는 프로젝션, 소팅 등의 항목을 넣을 수 있습니다. 예제 코드에서는 프로젝션만 사용했습니다.

필터는 단순하게 모든 몽고디비 Document가 가지고 있고 id로 사용하는 값인 _id 필드를 id값을 사용해 찾도록 했습니다. 업데이트 항목은 $inc: {hits:1}로 되어 있습니다. $inc는 값을 증가 시키고 싶을 때
사용하는 연산자입니다. hits : 1은 hits 항목을 1씩 증가시킨다는 의미입니다. 즉 게시글의 상세페이지에 들어갈 때 마다 hits가 1씩 증가합니다. 예제에는 없습니다만, 실무에서는 ip나 device 등을
체크해 어뷰징을 못하게 하는 방법을 사용합니다.


{{!-- <h1>{{title}}</h1>
{{!<h2 class="text-xl">제목입니다.</h2>}}
{{!1. 게시글의 제목을 표시하는 영역, 현재는 화면 확인용으로 임의의 값을 넣어두었습니다. 추후에 API를 작성하면서 변경하면 됨 }}
<div>
  작성자 :<b>작성자 이름</b>
</div>
{{!2. 작성자 이름이다. 제목과 마찬가지로 임의의값을 넣어둠 }}

<div>
  조회수 : 9999 | 작성일시 : 2022-01-01 00:00:00
  {{!3. 조회수와 작성일시를 표시하는 곳, API를 작성하면서 변경해야한다.}}
  <button onclick="odifyPost()">수정</button>
  {{!4. 게시글 관련 버튼 영역, 함수명을 미리 할당해두어 수정, 삭제가 가능하게 할 예정}}
  <button onclick="eletePost()">삭제</button>
</div>

<div>
  <pre>본문입니다. 하이요잉</pre>
  {{!5. 게시글의 본문 표시 영역, 개행을 쉽게 하기 위해 <pre> 태그를 사용함}}
</div> --}}
{{! 아래와 같이 수정한다.}}